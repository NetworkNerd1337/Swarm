{% extends "base.html" %}

{% block title %}Test Results - StreamSwarm{% endblock %}

{% block content %}
<div class="container">
    <!-- Header -->
    <div class="row mb-4">
        <div class="col">
            <h1 class="h2 mb-3">
                <i class="fas fa-chart-line me-2"></i>
                Test Results: {{ test.name }}
            </h1>
            <div class="d-flex align-items-center gap-3">
                <span class="badge bg-{{ 'success' if test.status == 'completed' else 'warning' if test.status == 'running' else 'secondary' }} fs-6">
                    {{ test.status | title }}
                </span>
                <span class="text-muted">Destination: <code>{{ test.destination }}</code></span>
                <span class="text-muted">Duration: {{ test.duration // 60 }}m {{ test.duration % 60 }}s</span>
            </div>
        </div>
        <div class="col-auto">
            <div class="btn-group" role="group">
                {% if test.status in ['completed', 'failed'] %}
                    <button class="btn btn-success" onclick="exportPDF({{ test.id }})">
                        <i class="fas fa-file-pdf me-1"></i> Export PDF Report
                    </button>
                {% endif %}
                <a href="{{ url_for('tests') }}" class="btn btn-outline-secondary">
                    <i class="fas fa-arrow-left me-1"></i>
                    Back to Tests
                </a>
            </div>
        </div>
    </div>

    <!-- Test Summary -->
    <div class="row mb-4">
        <div class="col-md-3 mb-3">
            <div class="card">
                <div class="card-body text-center">
                    <h5 class="card-title">Participating Clients</h5>
                    <h2 class="text-info">{{ clients | length }}</h2>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card">
                <div class="card-body text-center">
                    <h5 class="card-title">Data Points</h5>
                    <h2 class="text-success">{{ results | length }}</h2>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card">
                <div class="card-body text-center">
                    <h5 class="card-title">Avg Latency</h5>
                    <h2 class="text-warning" id="avg-latency">--</h2>
                </div>
            </div>
        </div>
        <div class="col-md-3 mb-3">
            <div class="card">
                <div class="card-body text-center">
                    <h5 class="card-title">Packet Loss</h5>
                    <h2 class="text-danger" id="avg-packet-loss">--</h2>
                </div>
            </div>
        </div>
    </div>

    <!-- Charts -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="card-title mb-0">
                            <i class="fas fa-chart-line me-2"></i>
                            Network Latency Over Time
                        </h5>
                        <div class="dropdown">
                            <button class="btn btn-outline-primary btn-sm dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                <span id="current-metric-label">Network Latency</span>
                            </button>
                            <ul class="dropdown-menu">
                                <li><h6 class="dropdown-header">Network Performance</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('ping_latency')">Network Latency</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('ping_packet_loss')">Packet Loss</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('jitter')">Network Jitter</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('dns_resolution_time')">DNS Resolution Time</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('tcp_connect_time')">TCP Connect Time</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('ssl_handshake_time')">SSL Handshake Time</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('ttfb')">Time to First Byte</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><h6 class="dropdown-header">System Performance</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('cpu_load_1min')">CPU Load (1min)</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('cpu_load_5min')">CPU Load (5min)</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('cpu_load_15min')">CPU Load (15min)</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('cpu_freq_current')">CPU Frequency</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><h6 class="dropdown-header">Network Interface</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('network_bytes_sent')">Bytes Sent</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('network_bytes_recv')">Bytes Received</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('network_errors_in')">Network Errors In</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('network_errors_out')">Network Errors Out</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><h6 class="dropdown-header">Storage Performance</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('disk_read_iops')">Disk Read IOPS</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('disk_write_iops')">Disk Write IOPS</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('disk_read_bytes_sec')">Disk Read Throughput</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('disk_write_bytes_sec')">Disk Write Throughput</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><h6 class="dropdown-header">Quality of Service</h6></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('dscp_value')">DSCP Values</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('cos_value')">CoS Values</a></li>
                                <li><a class="dropdown-item" href="#" onclick="showMetric('qos_policy_compliant')">QoS Policy Compliance</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
                <div class="card-body">
                    <canvas id="networkChart" height="400"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="row mb-4">
        <div class="col-lg-4 mb-4">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <i class="fas fa-microchip me-2"></i>
                        CPU Usage
                    </h5>
                </div>
                <div class="card-body">
                    <canvas id="cpuChart" height="300"></canvas>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4 mb-4">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <i class="fas fa-memory me-2"></i>
                        Memory Usage
                    </h5>
                </div>
                <div class="card-body">
                    <canvas id="memoryChart" height="300"></canvas>
                </div>
            </div>
        </div>
        
        <div class="col-lg-4 mb-4">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <i class="fas fa-hdd me-2"></i>
                        Disk Usage
                    </h5>
                </div>
                <div class="card-body">
                    <canvas id="diskChart" height="300"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Client Details -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h5 class="card-title mb-0">
                        <i class="fas fa-desktop me-2"></i>
                        Client Performance Summary
                    </h5>
                </div>
                <div class="card-body">
                    {% if clients %}
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead>
                                <tr>
                                    <th>Client</th>
                                    <th>Data Points</th>
                                    <th>Avg Latency</th>
                                    <th>Avg Packet Loss</th>
                                    <th>Avg CPU</th>
                                    <th>Avg Memory</th>
                                    <th>Avg Disk</th>
                                </tr>
                            </thead>
                            <tbody id="clientSummaryTable">
                                {% for client in clients %}
                                <tr>
                                    <td><strong>{{ client.hostname }}</strong></td>
                                    <td class="client-data-points" data-client="{{ client.id }}">--</td>
                                    <td class="client-avg-latency" data-client="{{ client.id }}">--</td>
                                    <td class="client-avg-packet-loss" data-client="{{ client.id }}">--</td>
                                    <td class="client-avg-cpu" data-client="{{ client.id }}">--</td>
                                    <td class="client-avg-memory" data-client="{{ client.id }}">--</td>
                                    <td class="client-avg-disk" data-client="{{ client.id }}">--</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>
                    {% else %}
                    <p class="text-muted mb-0">No client data available for this test.</p>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
let testData = {};
let networkChart, cpuChart, memoryChart, diskChart;
let currentMetric = 'ping_latency';

document.addEventListener('DOMContentLoaded', function() {
    loadTestData();
});

async function loadTestData() {
    try {
        console.log('Loading test data from: /api/test/{{ test.id }}/data');
        const response = await fetch(`/api/test/{{ test.id }}/data`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        testData = await response.json();
        console.log('Test data loaded successfully:', testData);
        
        // Check if we have valid data
        if (!testData || !testData.clients || Object.keys(testData.clients).length === 0) {
            console.log('No client data available');
            document.getElementById('avg-latency').textContent = '--';
            document.getElementById('avg-packet-loss').textContent = '--';
            return;
        }
        
        // Initialize charts and update stats
        initializeCharts();
        updateSummaryStats();
        updateClientSummary();
        
    } catch (error) {
        console.error('Error loading test data:', error);
        document.getElementById('avg-latency').textContent = '--';
        document.getElementById('avg-packet-loss').textContent = '--';
    }
}

function initializeCharts() {
    console.log('Initializing charts with data:', testData);
    
    if (!testData || !testData.clients || !testData.metrics) {
        console.error('Cannot initialize charts: missing data structure');
        return;
    }
    
    // Network Chart
    const networkCtx = document.getElementById('networkChart').getContext('2d');
    
    const colors = ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6f42c1'];
    const datasets = Object.keys(testData.clients).map((clientId, index) => {
        const color = colors[index % colors.length];
        const metricData = testData.metrics[currentMetric] && testData.metrics[currentMetric][clientId] 
            ? testData.metrics[currentMetric][clientId] 
            : [];
        
        console.log(`Client ${clientId} (${testData.clients[clientId]}) ${currentMetric} data:`, metricData.length, 'points');
        
        return {
            label: testData.clients[clientId],
            data: metricData,
            borderColor: color,
            backgroundColor: color + '20',
            fill: false,
            tension: 0.1
        };
    });

    networkChart = new Chart(networkCtx, {
        type: 'line',
        data: {
            datasets: datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: {
                    display: true,
                    text: getMetricTitle(currentMetric)
                },
                legend: {
                    display: true,
                    position: 'top'
                }
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'YYYY-MM-DDTHH:mm:ss.SSSSSS',
                        displayFormats: {
                            minute: 'HH:mm',
                            hour: 'HH:mm'
                        }
                    },
                    title: {
                        display: true,
                        text: 'Time'
                    }
                },
                y: {
                    title: {
                        display: true,
                        text: getMetricUnit(currentMetric)
                    },
                    beginAtZero: true
                }
            }
        }
    });

    // System Resource Charts
    initializeResourceCharts();
}

function initializeResourceCharts() {
    if (!testData || !testData.clients || !testData.metrics) {
        console.log('No data available for resource chart initialization');
        return;
    }
    
    const colors = ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6f42c1'];
    
    // CPU Chart
    const cpuCtx = document.getElementById('cpuChart').getContext('2d');
    const cpuDatasets = Object.keys(testData.clients).map((clientId, index) => ({
        label: testData.clients[clientId],
        data: (testData.metrics.cpu && testData.metrics.cpu[clientId]) || [],
        borderColor: colors[index % colors.length],
        backgroundColor: colors[index % colors.length] + '20',
        fill: false,
        tension: 0.1
    }));

    cpuChart = new Chart(cpuCtx, {
        type: 'line',
        data: { datasets: cpuDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'YYYY-MM-DDTHH:mm:ss.SSSSSS',
                        displayFormats: { minute: 'HH:mm' }
                    }
                },
                y: {
                    title: { display: true, text: 'CPU %' },
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });

    // Memory Chart
    const memoryCtx = document.getElementById('memoryChart').getContext('2d');
    const memoryDatasets = Object.keys(testData.clients).map((clientId, index) => ({
        label: testData.clients[clientId],
        data: (testData.metrics.memory && testData.metrics.memory[clientId]) || [],
        borderColor: colors[index % colors.length],
        backgroundColor: colors[index % colors.length] + '20',
        fill: false,
        tension: 0.1
    }));

    memoryChart = new Chart(memoryCtx, {
        type: 'line',
        data: { datasets: memoryDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'YYYY-MM-DDTHH:mm:ss.SSSSSS',
                        displayFormats: { minute: 'HH:mm' }
                    }
                },
                y: {
                    title: { display: true, text: 'Memory %' },
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });

    // Disk Chart
    const diskCtx = document.getElementById('diskChart').getContext('2d');
    const diskDatasets = Object.keys(testData.clients).map((clientId, index) => ({
        label: testData.clients[clientId],
        data: (testData.metrics.disk && testData.metrics.disk[clientId]) || [],
        borderColor: colors[index % colors.length],
        backgroundColor: colors[index % colors.length] + '20',
        fill: false,
        tension: 0.1
    }));

    diskChart = new Chart(diskCtx, {
        type: 'line',
        data: { datasets: diskDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'YYYY-MM-DDTHH:mm:ss.SSSSSS',
                        displayFormats: { minute: 'HH:mm' }
                    }
                },
                y: {
                    title: { display: true, text: 'Disk %' },
                    beginAtZero: true,
                    max: 100
                }
            }
        }
    });
}

function showMetric(metric) {
    currentMetric = metric;
    
    // Update dropdown label
    document.getElementById('current-metric-label').textContent = getMetricTitle(metric).replace(' Over Time', '');
    
    // Only update chart if it exists and testData is available
    if (networkChart && testData && testData.clients && testData.metrics) {
        const datasets = Object.keys(testData.clients).map((clientId, index) => {
            const colors = ['#007bff', '#28a745', '#ffc107', '#dc3545', '#17a2b8', '#6f42c1'];
            const color = colors[index % colors.length];
            
            return {
                label: testData.clients[clientId],
                data: testData.metrics[metric] && testData.metrics[metric][clientId] ? testData.metrics[metric][clientId] : [],
                borderColor: color,
                backgroundColor: color + '20',
                fill: false,
                tension: 0.1
            };
        });
        
        networkChart.data.datasets = datasets;
    networkChart.options.plugins.title.text = getMetricTitle(metric);
    networkChart.options.scales.y.title.text = getMetricUnit(metric);
        networkChart.update();
    }
}

function getMetricTitle(metric) {
    const titles = {
        'ping_latency': 'Network Latency Over Time',
        'ping_packet_loss': 'Packet Loss Over Time',
        'jitter': 'Network Jitter Over Time',
        'dns_resolution_time': 'DNS Resolution Time Over Time',
        'tcp_connect_time': 'TCP Connection Time Over Time',
        'ssl_handshake_time': 'SSL Handshake Time Over Time',
        'ttfb': 'Time to First Byte Over Time',
        'cpu_load_1min': 'CPU Load Average (1 minute) Over Time',
        'cpu_load_5min': 'CPU Load Average (5 minutes) Over Time',
        'cpu_load_15min': 'CPU Load Average (15 minutes) Over Time',
        'cpu_freq_current': 'CPU Frequency Over Time',
        'network_bytes_sent': 'Network Bytes Sent Over Time',
        'network_bytes_recv': 'Network Bytes Received Over Time',
        'network_errors_in': 'Network Errors (Incoming) Over Time',
        'network_errors_out': 'Network Errors (Outgoing) Over Time',
        'disk_read_iops': 'Disk Read IOPS Over Time',
        'disk_write_iops': 'Disk Write IOPS Over Time',
        'disk_read_bytes_sec': 'Disk Read Throughput Over Time',
        'disk_write_bytes_sec': 'Disk Write Throughput Over Time',
        'dscp_value': 'DSCP Values Over Time',
        'cos_value': 'CoS Values Over Time',
        'qos_policy_compliant': 'QoS Policy Compliance Over Time'
    };
    return titles[metric] || metric.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

function getMetricUnit(metric) {
    const units = {
        'ping_latency': 'Latency (ms)',
        'ping_packet_loss': 'Packet Loss (%)',
        'jitter': 'Jitter (ms)',
        'dns_resolution_time': 'DNS Time (ms)',
        'tcp_connect_time': 'Connect Time (ms)',
        'ssl_handshake_time': 'SSL Time (ms)',
        'ttfb': 'TTFB (ms)',
        'cpu_load_1min': 'Load Average',
        'cpu_load_5min': 'Load Average',
        'cpu_load_15min': 'Load Average',
        'cpu_freq_current': 'Frequency (MHz)',
        'network_bytes_sent': 'Bytes',
        'network_bytes_recv': 'Bytes',
        'network_errors_in': 'Error Count',
        'network_errors_out': 'Error Count',
        'disk_read_iops': 'Operations/sec',
        'disk_write_iops': 'Operations/sec',
        'disk_read_bytes_sec': 'Bytes/sec',
        'disk_write_bytes_sec': 'Bytes/sec',
        'dscp_value': 'DSCP Code',
        'cos_value': 'CoS Value',
        'qos_policy_compliant': 'Compliance (0/1)'
    };
    return units[metric] || 'Value';
}

function updateSummaryStats() {
    if (!testData || !testData.clients || !testData.metrics) {
        document.getElementById('avg-latency').textContent = '--';
        document.getElementById('avg-packet-loss').textContent = '--';
        return;
    }
    
    // Calculate average latency and packet loss
    let totalLatency = 0;
    let totalPacketLoss = 0;
    let latencyCount = 0;
    let packetLossCount = 0;
    
    Object.keys(testData.clients).forEach(clientId => {
        const latencyData = (testData.metrics.ping_latency && testData.metrics.ping_latency[clientId]) || [];
        const packetLossData = (testData.metrics.ping_packet_loss && testData.metrics.ping_packet_loss[clientId]) || [];
        
        latencyData.forEach(point => {
            if (point && point.y !== null && point.y !== undefined) {
                totalLatency += point.y;
                latencyCount++;
            }
        });
        
        packetLossData.forEach(point => {
            if (point && point.y !== null && point.y !== undefined) {
                totalPacketLoss += point.y;
                packetLossCount++;
            }
        });
    });
    
    const avgLatency = latencyCount > 0 ? (totalLatency / latencyCount).toFixed(1) : '--';
    const avgPacketLoss = packetLossCount > 0 ? (totalPacketLoss / packetLossCount).toFixed(1) : '--';
    
    document.getElementById('avg-latency').textContent = avgLatency + (avgLatency !== '--' ? ' ms' : '');
    document.getElementById('avg-packet-loss').textContent = avgPacketLoss + (avgPacketLoss !== '--' ? '%' : '');
}

function updateClientSummary() {
    if (!testData || !testData.clients || !testData.metrics) {
        return;
    }
    
    Object.keys(testData.clients).forEach(clientId => {
        const latencyData = (testData.metrics.ping_latency && testData.metrics.ping_latency[clientId]) || [];
        const packetLossData = (testData.metrics.ping_packet_loss && testData.metrics.ping_packet_loss[clientId]) || [];
        const cpuData = (testData.metrics.cpu && testData.metrics.cpu[clientId]) || [];
        const memoryData = (testData.metrics.memory && testData.metrics.memory[clientId]) || [];
        const diskData = (testData.metrics.disk && testData.metrics.disk[clientId]) || [];
        
        // Calculate averages
        const avgLatency = calculateAverage(latencyData);
        const avgPacketLoss = calculateAverage(packetLossData);
        const avgCpu = calculateAverage(cpuData);
        const avgMemory = calculateAverage(memoryData);
        const avgDisk = calculateAverage(diskData);
        
        // Update table cells
        const dataPointsCell = document.querySelector(`[data-client="${clientId}"].client-data-points`);
        const latencyCell = document.querySelector(`[data-client="${clientId}"].client-avg-latency`);
        const packetLossCell = document.querySelector(`[data-client="${clientId}"].client-avg-packet-loss`);
        const cpuCell = document.querySelector(`[data-client="${clientId}"].client-avg-cpu`);
        const memoryCell = document.querySelector(`[data-client="${clientId}"].client-avg-memory`);
        const diskCell = document.querySelector(`[data-client="${clientId}"].client-avg-disk`);
        
        if (dataPointsCell) dataPointsCell.textContent = latencyData.length;
        if (latencyCell) latencyCell.textContent = avgLatency !== null ? avgLatency.toFixed(1) + ' ms' : '--';
        if (packetLossCell) packetLossCell.textContent = avgPacketLoss !== null ? avgPacketLoss.toFixed(1) + '%' : '--';
        if (cpuCell) cpuCell.textContent = avgCpu !== null ? avgCpu.toFixed(1) + '%' : '--';
        if (memoryCell) memoryCell.textContent = avgMemory !== null ? avgMemory.toFixed(1) + '%' : '--';
        if (diskCell) diskCell.textContent = avgDisk !== null ? avgDisk.toFixed(1) + '%' : '--';
    });
}

function calculateAverage(dataPoints) {
    const validPoints = dataPoints.filter(point => point.y !== null && point.y !== undefined);
    if (validPoints.length === 0) return null;
    
    const sum = validPoints.reduce((acc, point) => acc + point.y, 0);
    return sum / validPoints.length;
}

// Auto-refresh data every 30 seconds for running tests
{% if test.status == 'running' %}
setInterval(loadTestData, 30000);
{% endif %}

function exportPDF(testId) {
    // Show loading state
    const btn = event.target.closest('button');
    const originalText = btn.innerHTML;
    btn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i> Generating PDF...';
    btn.disabled = true;
    
    // Create a temporary link to download the PDF
    const link = document.createElement('a');
    link.href = `/api/test/${testId}/export/pdf`;
    link.download = '';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    // Restore button after a delay
    setTimeout(() => {
        btn.innerHTML = originalText;
        btn.disabled = false;
        showToast('PDF report download started', 'success');
    }, 2000);
}
</script>
{% endblock %}
